#!/usr/bin/env ruby
# Tiller - Dynamic configuration generator, intended for use in Dockerfiles
# Named from the first ship-building (Docker) related term I could find that
# didn't have an existing gem named after it!
# Mark Round <github@markround.com>

VERSION = '0.3.0'

require 'erb'
require 'ostruct'
require 'yaml'
require 'fileutils'
require 'optparse'
require 'pp'
require 'json'
require 'socket'
require 'tiller/api'

# This is needed so we can enumerate all the loaded plugins later
class Class
  def subclasses
    ObjectSpace.each_object(Class).select { |c| c < self }
  end
end

def warn_merge(key, old, new, type, source)
  puts "Warning, merging duplicate #{type} values."
  puts "#{key} => '#{old}' being replaced by : '#{new}' from #{source}"
  new
end

# And we're on our way...
module Tiller
  # Set these two environment variables if you want to debug a configuration
  # in a temporary directory, or use the -b and -l arguments.
  # EG: $ ./bin/tiller -b /tmp/tiller/etc -l /tmp/tiller/lib
  config = {
    :tiller_base  => (ENV['tiller_base'].nil?)  ? '/etc/tiller' : ENV['tiller_base'],
    :tiller_lib   => (ENV['tiller_lib'].nil?)   ? '/usr/local/lib' : ENV['tiller_lib'],
    # This is the main variable, usually the only one you pass into Docker.
    :environment  => (ENV['environment'].nil?)  ? 'production' : ENV['environment']
  }

  # Parse command-line arguments
  config[:no_exec] = false
  config[:verbose] = false
  config['api_enable'] = false
  config['api_port'] = 6275

  optparse = OptionParser.new do |opts|
    opts.on('-n', '--no-exec', 'Do not execute a replacement process') do
      config[:no_exec] = true
    end
    opts.on('-v', '--verbose', 'Display verbose output') do
      config[:verbose] = true
    end
    opts.on('-a', '--api', 'Enable HTTP API') do
      config['api_enable'] = true
    end
    opts.on('-p', '--api-port [API_PORT]', 'HTTP API port') do |api_port|
      config['api_port'] = api_port
    end
    opts.on('-b', '--base-dir [BASE_DIR]', 'Override the tiller_base environment variable') do |base_dir|
      config[:tiller_base] = base_dir
    end
    opts.on('-l', '--lib-dir [LIB_DIR]', 'Override the tiller_lib environment variable') do |lib_dir|
      config[:tiller_lib] = lib_dir
    end
    opts.on('-e', '--environment [ENV]', 'Override the \'environment\' environment variable') do |environment|
      config[:environment] = environment
    end

    opts.on('-h', '--help', 'Display this screen') do
      puts opts
      puts 'Tiller also uses the environment variables tiller_base, environment'
      puts 'and tiller_lib (or they can be provided using the arguments shown above).'
      puts 'See https://github.com/markround/tiller for documentation and usage.'
      puts 'Current configuration hash follows :'
      pp config
      exit
    end
  end

  puts "tiller v#{VERSION} (https://github.com/markround/tiller) <github@markround.com>"

  optparse.parse!

  # Add tiller_lib to the LOAD PATH so we can pull in user-defined plugins
  $LOAD_PATH.unshift(config[:tiller_lib]) unless $LOAD_PATH.include?(config[:tiller_lib])

  require 'tiller/templatesource.rb'
  require 'tiller/datasource.rb'

  # Load the common YAML configuration file
  config.merge!(YAML.load(open(File.join(config[:tiller_base], 'common.yaml'))))

  if config[:verbose]
    puts "Using configuration from #{config[:tiller_base]}"
    puts "Using plugins from #{config[:tiller_lib]}/tiller"
    puts "Using environment #{config[:environment]}"
  end

  # Now load all our plugins
  template_sources = Array.new
  data_sources = Array.new
  template_sources |= config['template_sources']
  data_sources |= config['data_sources']

  # This looks a little counter-intuitive, but it's for a reason.
  # We load things this way so that we get an array (data_sources, for example)
  # That contains all the classes loaded, *in the order specified in common.yaml*
  # This is very important, as it means we can specify the defaults DataSource
  # first, for example and then let later DataSources override values from it.
  # Otherwise, iterating through the available classes results in them being
  # returned in no particular useful order.
  template_classes = Array.new
  template_sources.each do |t|
    require "tiller/template/#{t}.rb"
    template_classes |= TemplateSource.subclasses
  end

  data_classes = Array.new
  data_sources.each do |d|
    require "tiller/data/#{d}.rb"
    data_classes |= DataSource.subclasses
  end


  if config[:verbose]
    puts 'Template sources loaded ' + template_classes.to_s
    puts 'Data sources loaded ' + data_classes.to_s
  end


  # Get all Templates for the given environment
  templates = Hash.new
  template_classes.each do |template_class|
    ts = template_class.new(config)
    ts.templates.each do |t|
      templates[t] = ts.template(t)
    end
  end

  puts "Templates to build #{templates.keys}" if config[:verbose]

  # Now go through all our data sources and start to assemble our global_values
  # hash. As hashes are getting merged, new values will take precedence over
  # older ones, and a warning will be displayed.
  # We also add in 'environment' to start with as it's very useful for all
  # templates.
  global_values = { 'environment' => config[:environment] }
  data_classes.each do |data_class|
    global_values.merge!(data_class.new(config).global_values) do |key, old, new|
      warn_merge(key, old, new, 'global', data_class.to_s)
    end
  end

  # Now we go through each template we've identified, and get the
  # values for each one.
  all_templates = Hash.new
  templates.each do |template, content|
    values = Hash.new
    target_values = Hash.new

    # Now we populate the hash with values from each DataSource, warning if we
    # get duplicate values.
    data_classes.each do |data_class|
      dc = data_class.new(config)
      if dc.values(template) != nil
        values.merge!(dc.values(template)) do |key, old, new|
          warn_merge(key, old, new, 'data', data_class.to_s)
        end
      end

      # Now get target_values (where the file should be installed to,
      # permissions and so on)
      target_values.merge!(dc.target_values(template)) do |key, old, new|
        warn_merge(key, old, new, 'target', data_class.to_s)
      end
    end

    # If our data source returned no values (e.g. we don't build this template
    # for this environment), we move onto the next one.
    next if target_values.empty?

    # Now, we build the template
    puts "Building template #{template}" if config[:verbose]
    tiller = values.merge(global_values) do |key, old, new|
      warn_merge(key, old, new, 'global and local', 'merged configuration')
    end

    # Use an OpenStruct namespace, as it's way easier than faffing around with
    # manual binding, and also non-existing values just get replaced by <nil>
    # instead of failing on errors.
    ns = OpenStruct.new(tiller)
    parsed_template = ERB.new(content, nil, '-').result(ns.instance_eval { binding })

    # Write the template, and also create the directory path if it
    # doesn't exist.
    target_path = File.dirname(target_values['target'])
    FileUtils.mkdir_p(target_path) unless File.directory?(target_path)
    target = open(target_values['target'], 'w')
    target.puts(parsed_template)
    target.close

    # config is redundant in target_values, remove it for the final status hash.
    all_templates[template]={
        'merged_values' => tiller,
        'target_values' => target_values.reject{|k,v| k=='config'}
    }

    # Set permissions if we are running as root
    if Process::Sys.geteuid == 0
      puts "Setting ownership/permissions on #{target_values['target']}" if config[:verbose]
      if target_values.key?('perms')
        FileUtils.chmod(target_values['perms'], target_values['target'])
      end
      # Don't need to check for the presence of these, as they're ignored
      # if they are null.
      FileUtils.chown(target_values['user'], target_values['group'],
                      target_values['target'])
    else
      puts 'Not running as root, so not setting ownership/permissions on ' \
        "#{target_values['target']}" if config[:verbose]
    end

  end

  puts 'Template generation completed'

  # Final status structure for API
  tiller_api_hash={'config' => config, 'global_values' => global_values, 'templates' => all_templates}

  if config['api_enable']
    Thread.start{ tiller_api(tiller_api_hash) }
  end

  if config[:no_exec] == false && config.key?('exec')
    # All templates created, so let's start the replacement process
    puts "Executing #{config['exec']}..."

    # Fork and wait so API can continue to run
    fork do
      system(config['exec'])
    end

    puts "Child process forked." if config[:verbose]
    Process.wait
    puts "Child process finished, Tiller is stopping." if config[:verbose]
  end


end
